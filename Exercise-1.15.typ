#let starting-angle = 12.15
#let number-of-calls = 1
#let angles = (starting-angle,)

#while starting-angle > 0.1 {
  starting-angle /= 3
  angles.push(starting-angle)
  number-of-calls += 1
}
#let num-divisions = angles.len() - 1
a. The procedure `p` is applied #number-of-calls times. It is applied
until the absolute value of `angle` is less than 0.1. For each division,
an additional `p` call encloses `angle`, and it takes #num-divisions
divisions for 12.15 to be reduced to under 0.1. These are the approximate
values of `angle` after each division: #linebreak()
#align(center)[#angles.map(n => calc.round(n, digits: 3)).]

b. To calculate the order of growth in space, we must first 
recognize that the process is _linear recursive_, meaning that it 
grows a chain of deferred operations (`p` calls). The interpreter 
must keep track of these deferred `p` calls in memory space. 
Therefore, understanding  the number of `p` calls for a given `a` 
allows us to calculate the order of growth for space. The number 
of `p` calls grows once for every increase in the absolute value
of `a` such that an additional division by 3 must occur to reduce 
the absolute value of `a` to be less than 0.1.
Starting from an `a` of $3^(-3)$, which requires no divisions 
(requiring only 1 `p` call), `a` must be multiplied by 3 to 
increase the number of divisions by 1.

#let calc-calls(a) = {
  let num-calls = 1
  while a > 0.1 {
    a /= 3
    num-calls += 1
  }
  return num-calls
}
#let a-values = range(-3, 9).map(n => calc.round(calc.pow(3, n), digits: 3))
#let calls = a-values.map(a => [#calc-calls(a)])
#align(center)[
  #table(
    columns: 13,
    [*`a`*], ..a-values.map(a => [#a]),
    [*Number of Calls*], ..calls,
  )
]
This yields a formula of $R(n) = log_3(n) + 4$ ,where $n$ is the
initial absolute value of `a` and $R(n)$ is the maximum number of 
`p` calls that must be kept in memory. 

The order of growth in the number of steps is found by understanding
that the number of steps for each `p` call is the same regardless of
the value of `x` in (`p x`). Therefore, the total number of steps,
$T(n)$, will be $k dot R(n)$, where $k$ is a constant representing 
the number of steps in a `p` call. 

Therefore, the order of growth in space and number of steps (as a
function of $a$), used by the process generated by the `sine` 
procedure when (`sine a`) is evaluated is $Theta(log a)$.


