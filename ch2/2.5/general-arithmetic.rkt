#!/usr/bin/env racket
#lang sicp

(#%require "dispatch.rkt")
(#%require "apply-generic.rkt")
(#%require "poly-arithmetic.rkt")

(#%provide make-integer)
(#%provide make-rational)
(#%provide make-real)
(#%provide make-complex-from-real-imag)
(#%provide make-complex-from-mag-ang)
(#%provide make-polynomial)
(#%provide make-poly-sparse)
(#%provide make-poly-dense)

(#%provide real-part imag-part magnitude angle)
(#%provide numer denom)

(#%provide project)
(#%provide raise)
(#%provide drop)
(#%provide add-type)

(#%provide add)
(#%provide sub)
(#%provide mul)
(#%provide div)

(#%provide equ?)
(#%provide =zero?)

(#%provide negate)
(#%provide greatest-common-divisor)

(#%provide apply-generic)

(define (install-general-arithmetic-package)
  (install-integer-package)
  (install-rational-package)
  (install-real-package)
  (install-polar-package)
  (install-rectangular-package)
  (install-complex-package)
  (install-polynomial-package)
  'done)

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))

(define (raise type-object)
  (apply-generic-nd 'raise type-object))

(define (project type-object)
  (apply-generic-nd 'project type-object))

(define (install-integer-package)
  (define (reduce-integers n d)
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
  (define (raise integer)
    (make-rational integer 1))
  (put 'add '(integer integer)
       (lambda (x y) (+ x y)))
  (put 'sub '(integer integer)
       (lambda (x y) (- x y)))
  (put 'mul '(integer integer)
       (lambda (x y) (* x y)))
  (put 'div '(integer integer)
       (lambda (x y) (/ x y)))
  (put 'greatest-common-divisor '(integer integer) gcd)
  (put 'square-root '(integer)
       (lambda (x) (make-real (sqrt x))))
  (put 'cosine '(integer)
       (lambda (x) (make-real (cos x))))
  (put 'sine '(integer)
       (lambda (x) (make-real (sin x))))
  (put 'arctan '(integer integer)
       (lambda (x y) (make-real (atan x y))))
  (put 'raise '(integer)
       (lambda (x) (make-rational x 1)))
  (put 'negate '(integer)
       (lambda (x) (- x)))
  (put 'equ? '(integer integer)
       (lambda (x y) (= x y)))
  (put '=zero? '(integer)
       (lambda (x) (= x 0)))
  (put 'reduce '(integer integer) reduce-integers)
  (put 'make 'integer (lambda (x) x))
  'done)
(define (make-integer n)
  ((get 'make 'integer) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((reduced (reduce n d)))
      (cons (car reduced) (cadr reduced))))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))
  (define (square-root x)
    (make-rational (make-real (sqrt (numer x)))
                   (make-real (sqrt (denom x)))))
  (define (cosine x)
    (make-real (cos (div (numer x) (denom x)))))
  (define (sine x)
    (make-real (sin (div (numer x) (denom x)))))
  (define (arctan x y)
    (make-real (atan (div (numer x) (denom x))
                     (div (numer y) (denom y)))))
  (define (raise rational)
    (if (or (eq? 'polynomial (type-tag (numer rational)))
            (eq? 'polynomial (type-tag (denom rational))))
        rational
        (make-real (div (numer rational) (denom rational)))))
  (define (project rational)
    (if (or (eq? 'polynomial (type-tag (numer rational)))
            (eq? 'polynomial (type-tag (denom rational))))
        rational
        (make-integer
          (round (contents
                   (div (numer rational) (denom rational)))))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'square-root '(rational) square-root)
  (put 'cosine '(rational) cosine)
  (put 'sine '(rational) sine)
  (put 'arctan '(rational rational) arctan)
  (put 'raise '(rational) raise)
  (put 'project '(rational) project)
  (put 'negate '(rational)
       (lambda (x)
         (make-rational (negate (numer x)) (denom x))))
  (put 'equ? '(rational rational)
    (lambda (x y)
      (and (eq? (numer x) (numer y))
       ; cannot divide by 0
       (lambda (x) (=zero? (numer x))))))
  (put '=zero? '(rational)
       (lambda (x) (=zero? (numer x))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-real-package)
  (define (raise real)
    (make-complex-from-real-imag (tag real) 0))
  (define (project real)
    (make-integer (round real)))
  (define (tag x) (attach-tag 'real x))
  (put 'add '(real real)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(real real)
       (lambda (x y) (tag (* x y))))
  (put 'div '(real real)
       (lambda (x y) (tag (/ x y))))
  (put 'square-root '(real)
       (lambda (x) (tag (sqrt x))))
  (put 'cosine '(real)
       (lambda (x) (tag (cos x))))
  (put 'sine '(real)
       (lambda (x) (tag (sin x))))
  (put 'arctan '(real real)
       (lambda (x y) (tag (atan x y))))
  (put 'raise '(real) raise)
  (put 'project '(real) project)
  (put 'negate '(real)
       (lambda (x) (make-real (- x))))
  (put 'equ? '(real real) =)
  (put '=zero? '(real)
       (lambda (x) (= x 0)))
  (put 'reduce '(real real)
       (lambda (x y) (list (tag x) (tag y))))
  (put 'make 'real
       (lambda (x)
         (if (eq? (type-tag x) 'real)
             x
             (tag x))))
  'done)

(define (make-real num)
  ((get 'make 'real) num))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  (define (project complex)
    (make-real (real-part complex)))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'project '(complex) project)
  (put 'negate '(complex)
       (lambda (x)
         (make-complex-from-real-imag
           (negate (real-part x))
           (negate (imag-part x)))))
  (put 'equ? '(complex complex)
       (lambda (x y)
         (and (equ? (real-part x) (real-part y))
              (equ? (imag-part x) (imag-part y)))))
  (put '=zero? '(complex)
       (lambda (x) (=zero? (magnitude x))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (square x) (mul x x))
(define (square-root x) (apply-generic 'square-root x))
(define (cosine x) (apply-generic 'cosine x))
(define (sine x) (apply-generic 'sine x))
(define (arctan x y) (apply-generic 'arctan x y))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (square-root (add (square (real-part z))
                      (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z) (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (square-root (add (square x) (square y)))
          (arctan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-real-ang 'polar) r a))

(define (numer rat) (apply-generic 'numer rat))
(define (denom rat) (apply-generic 'denom rat))

(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))

(define (negate x) (apply-generic 'negate x))

(define (greatest-common-divisor x y)
  (apply-generic 'greatest-common-divisor x y))
(define (reduce n d)
  (apply-generic 'reduce n d))

(install-general-arithmetic-package)
